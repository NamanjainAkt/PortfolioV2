/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from 'three'
import React, { useRef, useEffect, useState } from 'react'
import { useGLTF } from '@react-three/drei'
import { useFrame, ThreeElements } from '@react-three/fiber'
import { GLTF } from 'three-stdlib'

type GLTFResult = GLTF & {
  nodes: {
    [key: string]: THREE.Mesh // Simplified type for brevity
  }
  materials: {
    [key: string]: THREE.MeshStandardMaterial
  }
}

export function Model(props: ThreeElements['group']) {
  const { nodes, materials } = useGLTF('/model.glb') as GLTFResult
  
  // 1. Create Refs for the parts we want to move
  const groupRef = useRef<THREE.Group>(null)
  const headRef = useRef<THREE.Group>(null)
  const legRightRef = useRef<THREE.Group>(null)
  const legLeftRef = useRef<THREE.Group>(null)
  const bodyRef = useRef<THREE.Group>(null) // We will wrap the body meshes in this

  // 2. Controls State (WASD)
  const [movement, setMovement] = useState({ forward: false, backward: false })

  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if(e.key === 'w' || e.key === 'W') setMovement(m => ({...m, forward: true}));
      if(e.key === 's' || e.key === 'S') setMovement(m => ({...m, backward: true}));
    };
    const handleKeyUp = (e: KeyboardEvent) => {
      if(e.key === 'w' || e.key === 'W') setMovement(m => ({...m, forward: false}));
      if(e.key === 's' || e.key === 'S') setMovement(m => ({...m, backward: false}));
    };
    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);
    return () => {
        window.removeEventListener('keydown', handleKeyDown);
        window.removeEventListener('keyup', handleKeyUp);
    };
  }, []);

  // 3. The Animation Loop
  useFrame((state) => {
    const t = state.clock.getElapsedTime();
    const mouse = state.mouse;

    // --- LOOK AROUND (HEAD) ---
    if (headRef.current) {
       // Look Left/Right
       headRef.current.rotation.y = THREE.MathUtils.lerp(headRef.current.rotation.y, mouse.x * 0.8, 0.1);
       // Look Up/Down
       headRef.current.rotation.x = THREE.MathUtils.lerp(headRef.current.rotation.x, -mouse.y * 0.5, 0.1);
    }

    // --- WALKING ---
    if (groupRef.current && legLeftRef.current && legRightRef.current && bodyRef.current) {
        if (movement.forward || movement.backward) {
            const walkSpeed = 8;
            const stride = 0.6; 
            const moveSpeed = 0.05;
            const direction = movement.forward ? 1 : -1;

            // Move entire robot
            groupRef.current.position.z += direction * moveSpeed;

            // Swing Legs (Sine Wave)
            legLeftRef.current.rotation.x = Math.sin(t * walkSpeed) * stride;
            legRightRef.current.rotation.x = Math.sin(t * walkSpeed + Math.PI) * stride; // +PI makes it opposite

            // Bob Body up/down
            bodyRef.current.position.y = Math.sin(t * walkSpeed * 2) * 0.05;
            // Bob Head slightly too (to match body)
            if(headRef.current) headRef.current.position.y = 1.545 + Math.sin(t * walkSpeed * 2) * 0.05;

        } else {
            // Reset to idle
            legLeftRef.current.rotation.x = THREE.MathUtils.lerp(legLeftRef.current.rotation.x, 0, 0.1);
            legRightRef.current.rotation.x = THREE.MathUtils.lerp(legRightRef.current.rotation.x, 0, 0.1);
            bodyRef.current.position.y = THREE.MathUtils.lerp(bodyRef.current.position.y, 0, 0.1);
        }
    }
  })

  return (
    <group ref={groupRef} {...props} dispose={null}>
      
      {/* HEAD GROUP */}
      <group ref={headRef} position={[-0.003, 1.545, 0.99]} rotation={[0.174, 0.02, -0.004]}>
        <mesh castShadow receiveShadow geometry={nodes.Mesh_0004.geometry} material={materials['color:128:128:128']} />
        <mesh castShadow receiveShadow geometry={nodes.Mesh_0004_1.geometry} material={materials['color:128:128:128_#19']} />
        <mesh castShadow receiveShadow geometry={nodes.Mesh_0004_2.geometry} material={materials['Aluminum_Polished_#2']} />
        <mesh castShadow receiveShadow geometry={nodes.Mesh_0004_3.geometry} material={materials['Aluminum_Polished_#2.001']} />
        <mesh castShadow receiveShadow geometry={nodes.Mesh_0004_4.geometry} material={materials['Anodized_Aluminum_Brushed_Black_#1']} />
        <mesh castShadow receiveShadow geometry={nodes.Mesh_0004_5.geometry} material={materials['Glass_(Solid)_Yellow_#1']} />
        <mesh castShadow receiveShadow geometry={nodes.Mesh_0004_6.geometry} material={materials['Metal_Polished_Grey_#1']} />
        <mesh castShadow receiveShadow geometry={nodes.Mesh_0004_7.geometry} material={materials['color:0:94:255']} />
        <mesh castShadow receiveShadow geometry={nodes.Mesh_0004_8.geometry} material={materials['color:128:128:128.001']} />
        <mesh castShadow receiveShadow geometry={nodes.Mesh_0004_9.geometry} material={materials['color:192:192:192']} />
        <mesh castShadow receiveShadow geometry={nodes.Mesh_0004_10.geometry} material={materials['color:64:64:64']} />
      </group>

      {/* RIGHT LEG GROUP (Positive X position) */}
      <group ref={legRightRef} position={[1.157, -1.621, 0.221]} rotation={[0.026, -0.1, 0.107]}>
        <mesh castShadow receiveShadow geometry={nodes.Mesh_0003.geometry} material={materials['Aluminum_Polished_#2.001']} />
        <mesh castShadow receiveShadow geometry={nodes.Mesh_0003_1.geometry} material={materials['Anodized_Aluminum_Brushed_90___Black_#1']} />
        <mesh castShadow receiveShadow geometry={nodes.Mesh_0003_2.geometry} material={materials['Silicone_Rubber_White_#1']} />
        <mesh castShadow receiveShadow geometry={nodes.Mesh_0003_3.geometry} material={materials['color:0:94:255']} />
        <mesh castShadow receiveShadow geometry={nodes.Mesh_0003_4.geometry} material={materials['color:128:128:128.001']} />
        <mesh castShadow receiveShadow geometry={nodes.Mesh_0003_5.geometry} material={materials['color:232:113:8']} />
        <mesh castShadow receiveShadow geometry={nodes.Mesh_0003_6.geometry} material={materials['color:64:64:64']} />
      </group>

      {/* LEFT LEG GROUP (Negative X position) */}
      <group ref={legLeftRef} position={[-1.293, -1.613, -0.077]} rotation={[-0.023, 0.084, 0.035]}>
        <mesh castShadow receiveShadow geometry={nodes.Mesh_0002.geometry} material={materials['Aluminum_Polished_#2.001']} />
        <mesh castShadow receiveShadow geometry={nodes.Mesh_0002_1.geometry} material={materials['Anodized_Aluminum_Brushed_90___Black_#1']} />
        <mesh castShadow receiveShadow geometry={nodes.Mesh_0002_2.geometry} material={materials['Silicone_Rubber_White_#1']} />
        <mesh castShadow receiveShadow geometry={nodes.Mesh_0002_3.geometry} material={materials['color:0:94:255']} />
        <mesh castShadow receiveShadow geometry={nodes.Mesh_0002_4.geometry} material={materials['color:128:128:128.001']} />
        <mesh castShadow receiveShadow geometry={nodes.Mesh_0002_5.geometry} material={materials['color:232:113:8']} />
        <mesh castShadow receiveShadow geometry={nodes.Mesh_0002_6.geometry} material={materials['color:64:64:64']} />
      </group>

      {/* BODY MESHES (Wrapped in a new group for animation) */}
      <group ref={bodyRef}>
        <mesh castShadow receiveShadow geometry={nodes.Mesh_0001.geometry} material={materials['Aluminum_Polished_#2.001']} />
        <mesh castShadow receiveShadow geometry={nodes.Mesh_0001_1.geometry} material={materials['Anodized_Aluminum_Brushed_90___Black_#1']} />
        <mesh castShadow receiveShadow geometry={nodes.Mesh_0001_2.geometry} material={materials['color:0:94:255']} />
        <mesh castShadow receiveShadow geometry={nodes.Mesh_0001_3.geometry} material={materials['color:128:128:128.001']} />
        <mesh castShadow receiveShadow geometry={nodes.Mesh_0001_4.geometry} material={materials['color:192:192:192']} />
        <mesh castShadow receiveShadow geometry={nodes.Mesh_0001_5.geometry} material={materials['color:232:113:8']} />
        <mesh castShadow receiveShadow geometry={nodes.Mesh_0001_6.geometry} material={materials['color:252:188:132']} />
        <mesh castShadow receiveShadow geometry={nodes.Mesh_0001_7.geometry} material={materials['color:64:64:64']} />
      </group>
      
    </group>
  )
}

useGLTF.preload('/model.glb')